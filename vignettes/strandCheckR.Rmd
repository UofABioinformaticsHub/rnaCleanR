---
title: "An Introduction To strandCheckR"
author:
-   name: Thu-Hien To
    affiliation: Bioinformatics Hub, University of Adelaide
    email: hien.to@adelaide.edu.au
-   name: Steve Pederson
    affiliation: Bioinformatics Hub, University of Adelaide
    email: stephen.pederson@adelaide.edu.au
package: strandCheckR
output:
    BiocStyle::html_document
vignette: >
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
    %\VignetteIndexEntry{An Introduction To strandCheckR}
---

# Introduction

*strandCheckR* is a package which uses a sliding window across a bam file and
returns the count/coverage of reads mapping to +/- strand in each window.
The returned DataFrame gives information across the whole genome through each
sliding window which clearly quantifies the strandedness of reads. 
The approach can be applied to detect possible DNA contamination within a 
strand specific RNA-seq experiment by assessing whether each window contains 
reads mainly from one strand, as would be expected from RNA molecules, or from 
both strands, as would be expected from contaminating DNA. 
This information can be used as an additional quality checking step for 
strand-specific RNA-Seq data.
The package can also be used to detect regions with specific behavior (e.g. 
highest number of reads) through the whole genome or within feature regions.

The main function `getStrandFromBamFile()` is designed flexibly so that users 
can filter low mapping quality reads, set read proportion which overlap a 
window, set window length & step etc. 
It was also implemented in an efficient way to manange large bam files. 
For a typical human RNA-seq bam file, it takes about 3 minutes to scan and get 
strand information using a standard laptop (2.3 GHz i5 CPU, 16 GB RAM).

A function to filter out reads coming from double stranded DNA is also provided.
For each sliding window, it considers the proportion of +/- stranded reads 
comparing to a given threshold, to decide if a window contains reads derived 
from RNA moluecules (i.e. single-stranded) or double stranded genomic DNA.
Any read which belongs to any window not decided as being derived from RNA 
will be removed. 
Read that belong to some windows coming from RNA will be kept with aprobability
calculated based on the proportion of +/- stranded reads from these windows.

# Get Sliding Window Strand Information

The function `getStrandFromBamFile()` is used to get the number of +/- stranded 
reads from all sliding windows throughout a list of bam files.
The bam files should be sorted and have their index files located at the same 
path as well.


```{r getWin, message=FALSE, warning=FALSE}
library(strandCheckR)
files <- system.file(
    "extdata", c("s1.sorted.bam", "s2.sorted.bam"), package = "strandCheckR"
    )
win <- getStrandFromBamFile(files, sequences = "10")
# shorten the file name
win$File <- basename(as.character(win$File))
win
```

The returned DataFrame has 10 columns that correspond to the read type (R1 or
R2 or single end read), sequence names, starting & ending bases of the windows 
(by default the window length is 1000 and the window step is 100), number of 
positive & negative reads that overlap each window (*NbPositive*, 
*NbNegative*), number of positive & negative bases that overlap each window 
(*CovPositive*, *CovNegative*), the maximum coverage (*MaxCoverage*) and the 
file name (*File*). Windows that do not overlap with any read are not reported.

The windows with highest read counts, for example, can be obtained as follows.

```{r highestCoverage, eval=TRUE, message=FALSE, warning=FALSE}
o <- order((win$NbPos+win$NbNeg), decreasing=TRUE)
win[head(o), ]
```

Here is an example for paired end bam file.

```{r paired end, eval=TRUE, message=FALSE, warning=FALSE}
fileP <- system.file("extdata", "paired.bam", package = "strandCheckR")
winP <- getStrandFromBamFile(fileP, sequences = "10")
winP$File <- basename(as.character(winP$File)) #shorten file name
winP
```

# Compare to a GRanges Object Defining Features

If you have annotation data, you can integrate it with the sliding windows 
obtained from the previous step using the function `intersectWithFeature()`.
The annotation must be a GRanges object, and can be provided with or without 
any *mcols*. 
Make sure that sequence names in returned windows and the annotation data are 
consistent.
By default, you will have an additional column in the returned windows which 
indicates whether a window overlaps any feature in the annotation object. 
You can also obtain details of the overlapped features in the *mcols* of the 
annotation object by specifying it in the *mcolsAnnnot* parameter.

```{r intersect, eval=TRUE, warning=FALSE, message=FALSE}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
annot <- transcripts(TxDb.Hsapiens.UCSC.hg38.knownGene)
#add chr before the sequence names to be consistent with the annot data
win$Seq <- paste0("chr", win$Seq) 
win <- intersectWithFeature(
    windows = win, annotation = annot, overlapCol = "OverlapTranscript"
    )
win
```


If you have a *gtf* or *gff* file, these can be imported using one of the 
multiple import functions provided by other Bioconductor packages.

# Plotting Histogram and Window Information

With the obtained windows, you can have generate plots via `plotHist()` and 
`plotWin()`

To plot the distribution of windows based on the proportion of reads aligning 
to the + strand (i.e. positive proportion), we can use the function 
`plotHist()`. 
This function will first calculate the frequency of + strand proportions over 
all windows, and also group/normalize them based on given column names. 
It then uses the *geom_bar* function from *ggplot2* to plot these frequencies. 
These plots are able indicate how much double-strand DNA is contained in each 
bam file. 
In perfectly clean ss-RNA-seq, the positive proportion of every window should 
be near 0\% or 100\%. 
The more amount of windows with proportions around 50\%, the more the 
sample was likely contaminated by DNA or some other material. 

```{r plotHist, eval=TRUE, message=FALSE, warning=FALSE}
plotHist(
    windows = win, groupBy = c("File", "OverlapTranscript"), 
    normalizeBy = "File", scales = "free_y"
    )
```

In this example, file *s2.sorted.bam* seems to be contaminated with double 
strand DNA, while file *s1.sorted.bam* is cleaner. 
By default, the windows are split into 4 coverage groups *<10*, *10-100*, 
*100-1000*, and *>1000*.
This can be modified via the argument *split*.

For paired-end data, we can group the DataFrame by read type:

```{r plotHistPaired, eval=TRUE, message=FALSE, warning=FALSE}
plotHist(
    windows = winP, groupBy = "Type", normalizeBy = "Type", scales = "free_y"
    )
```

A heatmap can be used instead of the classic barplot for histograms by 
specifying *heatmap=TRUE*. 
This can be useful for visualising mutliple files in the same plot.

```{r heatMap, eval=TRUE, message = FALSE, warning=FALSE, }
plotHist(
    windows = win, groupBy = c("File", "OverlapTranscript"), 
    normalizeBy = "File", heatmap = TRUE
    )
```


`plotWin()` creates a plot on the number of reads vs positive proportion for 
each window. 
By default, 4 lines correspond to possible filtering thresholds 
(0.6, 0.7, 0.8, 0.9). 
Threshold is a parameter that is used when filtering a bam file using 
`filterDNA()`. 
Given a threshold, a positive (resp. negative) window is kept if and only if it 
is above (resp. below) the corresponding threshold line on this plot. 
This can be used to provide guidance as to the best threshold to choose when 
filtering bam files.

```{r plotwin, eval=TRUE, message=FALSE, warning=FALSE}
plotWin(win, groupBy = "File")
```

# Filter bam files

The function `filterDNA()` removes potential double stranded DNA from a bam file 
using the given threshold.

```{r filterDNA, eval=TRUE, message=FALSE, warning=FALSE, results=FALSE}
win2 <- filterDNA(
    file = files[[2]], sequences = "10", destination = "s2.filter.bam", 
    threshold = 0.7, getWin = TRUE
    )
```


Other parameters can be specified for more flexible filtering.
You are able to define the ranges that you want to always keep (i.e. gene loci),
the minimum number of reads under which you want to ignore a window, the 
*pvalue* threshold for keeping a windows etc. 
The manual page of the function provides more options and explanations.

A comparison of the windows before and after filtering is given below.

```{r compare, eval=TRUE, message=FALSE, warning=FALSE, fig.cap="Distribution of windows based on stranded alignments, before and after removing reads from windows with ambiguous strandedness."}
win2$File <- basename(as.character(win2$File))
win2$File <- factor(win2$File, levels = c("s2.sorted.bam", "s2.filter.bam"))
plotHist(win2, groupBy = "File", normalizeBy = "File", scales = "free_y")
```