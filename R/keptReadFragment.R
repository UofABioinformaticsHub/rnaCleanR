#' @title calculate the read fragments to be kept
#' @description  calculate the keeping probability of each read fragment based 
#' on the keeping probability of the windows containing it. Then get the list 
#' of read fragments to be kept.
#' @param fragments an IRange object defind the starting, ending position of 
#' each fragment
#' @param keptProbaW an Rle object define the kept probability of each 
#' sliding window
#' @param errorRate the rate that a read has wrong strand
#' 
#' @return an integer vector of read fragment indices to be kept
#' @importFrom stats rbinom
#' 

keptReadFragment <- function(fragments,keptProbaW,errorRate){
    if(length(fragments)>0){
        minL <- min(width(fragments))
        maxL <- max(width(fragments))
        proba <- rep(0,length(fragments))
        for (m in minL:maxL){
            id <- which(width(fragments)==m)
            x <- keptProbaW[start(fragments)[id]]
            if (m>1){
                for (j in 1:(m-1)){
                    y <- keptProbaW[j+start(fragments)[id]]
                    x <-  (x>=y)*x + (y>x)*y 
                }
            }
            suppressWarnings(proba[id] <- rbinom(length(id),1,as.vector(x)))
            rm(id)
            rm(x)
        }
        return(which(proba==1))
    } else{
        return(c())
    }
}

