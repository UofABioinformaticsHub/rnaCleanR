# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title  Compute strand information of sliding window 
#'
#' @description Compute the positive proportion and the value to be tested afterward to decide whether the window is kept or not (this value is calculated from the estimated proportion and error).
#' This method is used in the functions filterOne and filterMulti when we don't need other information of the windows for plotting.
#' 
#' @param covPosLen the run length of an Rle object which is the coverage comes from positive reads
#' @param covPosVal the run value of an Rle object which is the coverage comes from positive reads
#' @param covNegLen the run length of an Rle object which is the coverage comes from negative reads
#' @param covNegVal the run value of an Rle object which is the coverage comes from negative reads
#' @param end the last base on the reference chromosome that the sliding window atteint
#' @param readLength the average length of reads
#' @param win the size of the sliding window
#' @param step the step of the sliding window
#' @param minCov if a window has the max coverage smaller than minCov, then it will be rejected regardless its strand proportion.
#' @param maxCov if a window has the max coverage greater than maxCov, then it will be kept regardless its strand proportion. If maxCov=0 then it doesn't have any effect on selecting windows.
#' @param logitThreshold the logit of the threshold
#'
#' @return A list of two data frames Plus and Minus which respectively contains information of positive windows and negative windows. 
#' Each data frame contains the information of window number, proportion of postive reads, and the value to be tested afterward to decide whether the window is kept or not (this value is calculated from the estimated proportion and error).
#' 
#' @seealso filterOne, filterMulti
#' 
#' @examples
#' bamfilein <- system.file("data","s1.chr1.bam",package = "rnaCleanR")
#' alignment <- GenomicAlignments::readGAlignments(bamfilein) 
#' alignmentInChr1 <- alignment[seqnames(alignment)=="1"] 
#' covPos <- alignmentInChr1[strand(alignment)=="+"] %>% GenomicAlignments::coverage() 
#' covNeg <- alignmentInChr1[strand(alignment)=="-"] %>% GenomicAlignments::coverage() 
#' len <- length(covChr)
#' readLength <- 100
#' win <- 1000
#' step <- 100
#' minCov <- 0
#' maxCov <- 0
#' logitThreshold <- binomial()$linkfun(0.7) 
#' windows <- rnaCleanR::computeWin(runLength(covPos),runValue(covPos),runLength(covNeg),runValue(covNeg),readLength,len,win,step,minCov,maxCov,logitThreshold)
#' 
#' @export
#' 
computeWin <- function(covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov, maxCov, logitThreshold) {
    .Call('rnaCleanR_computeWin', PACKAGE = 'rnaCleanR', covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov, maxCov, logitThreshold)
}

#' @title  Compute strand information of sliding window (plot version)
#'
#' @description Compute the positive proportion, sum of reads, max coverage and the group of each window. Windows are grouped based on their maximum coverage: by default definition, groups spead from 1 to 4, which correspond to the max coverage respectively in the range "0-10","10-100","100-1000",">1000"
#' This method is used in the getPlot function when we only need the information to plot, and do not need to filter the reads afterward.
#' 
#' @param covPosLen the run length of an Rle object which is the coverage comes from positive reads
#' @param covPosVal the run value of an Rle object which is the coverage comes from positive reads
#' @param covNegLen the run length of an Rle object which is the coverage comes from negative reads
#' @param covNegVal the run value of an Rle object which is the coverage comes from negative reads
#' @param end the last base on the reference chromosome that the sliding window atteint
#' @param readLength the average length of reads
#' @param win the size of the sliding window
#' @param step the step of the sliding window
#' @param minCov if a window has the max coverage least than minCov, then it will not be counted
#'
#' @return A list of two data frames Plus and Minus which respectively contains information of positive windows and negative windows: 'win' is the window number, and 'value' is the normalized estimated value to be tested
#' Each data frame contains contain the information of proportion of postive reads, the max coverage and the group of max coverage
#' @examples
#' bamfilein <- system.file("data","s1.chr1.bam",package = "rnaCleanR")
#' alignment <- GenomicAlignments::readGAlignments(bamfilein) 
#' alignmentInChr1 <- alignment[seqnames(alignment)=="1"] 
#' covPos <- alignmentInChr1[strand(alignment)=="+"] %>% GenomicAlignments::coverage() 
#' covNeg <- alignmentInChr1[strand(alignment)=="-"] %>% GenomicAlignments::coverage() 
#' len <- length(covChr)
#' readLength <- 100
#' win <- 1000
#' step <- 100
#' minCov <- 0
#' windows <- rnaCleanR::computeWinPlot(runLength(covPos),runValue(covPos),runLength(covNeg),runValue(covNeg),readLength,len,win,step,minCov)
#' 
#' 
#' @export
#' 
computeWinPlot <- function(covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov) {
    .Call('rnaCleanR_computeWinPlot', PACKAGE = 'rnaCleanR', covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov)
}

#' @title  Compute strand information of sliding window (verbose version)
#'
#' @description Compute the positive proportion, the normalized value to be tested afterward to decide whether the window is kept or not, the sum of reads, the maximum coverage, and the group of each window. Windows are grouped based on their maximum coverage: by default definition, groups spead from 1 to 4, which correspond to the max coverage respectively in the range "0-10","10-100","100-1000",">1000"
#' This method is used in the method filterOne when we have to filter the input bam files together with plotting the window information.
#' 
#' @param covPosLen the run length of an Rle object which is the coverage comes from positive reads
#' @param covPosVal the run value of an Rle object which is the coverage comes from positive reads
#' @param covNegLen the run length of an Rle object which is the coverage comes from negative reads
#' @param covNegVal the run value of an Rle object which is the coverage comes from negative reads
#' @param end the last base on the reference chromosome that the sliding window atteint
#' @param readLength the average length of reads
#' @param win the size of the sliding window
#' @param step the step of the sliding window
#' @param minCov if a window has the max coverage smaller than minCov, then it will be rejected regardless its strand proportion.
#' @param maxCov if a window has the max coverage greater than maxCov, then it will be kept regardless its strand proportion. If maxCov=0 then it doesn't have any effect on selecting windows.
#' @param logitThreshold the logit of the threshold
#'
#' @return A list of two data frames Plus and Minus which respectively contains information of positive windows and negative windows.
#' Each data frame contains the information of window number, proportion of postive reads, the normalized value calculated from the estimated proportion and error, the sum of reads, the max coverage and the group of max coverage.
#' @examples
#' bamfilein <- system.file("data","s1.chr1.bam",package = "rnaCleanR")
#' alignment <- GenomicAlignments::readGAlignments(bamfilein) 
#' alignmentInChr1 <- alignment[seqnames(alignment)=="1"] 
#' covPos <- alignmentInChr1[strand(alignment)=="+"] %>% GenomicAlignments::coverage() 
#' covNeg <- alignmentInChr1[strand(alignment)=="-"] %>% GenomicAlignments::coverage() 
#' len <- length(covChr)
#' readLength <- 100
#' win <- 1000
#' step <- 100
#' minCov <- 0
#' maxCov <- 0
#' logitThreshold <- binomial()$linkfun(0.7) 
#' windows <- rnaCleanR::computeWinVerbose(runLength(covPos),runValue(covPos),runLength(covNeg),runValue(covNeg),readLength,len,win,step,minCov,maxCov,logitThreshold)
#' 
#' @export
#' 
computeWinVerbose <- function(covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov, maxCov, logitThreshold) {
    .Call('rnaCleanR_computeWinVerbose', PACKAGE = 'rnaCleanR', covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov, maxCov, logitThreshold)
}

#' @title  Calculate the reads to be kept.
#'
#' @description Calculate the reads to be kept based of the strand proportion of kept windows. This function is called by the functions filterOne or filterMulti.
#' If a kept window has more positive alignments than negative alignments, then 
#' each postive alignment in that window is kept with a probability equal to (positive proportion -  negative proportion)/(positive proportion); and each negative alignment of that window is kept with a probability equal to the given errorRate (0.01 by default). Similarly for windows that have negative alignments more than positive alingments.
#' Since each alignment can be belonged to several windows, then the final probability for keeping of each alignment is the maximum one from all windows containing it.
#' @param posFragments the data frame contains the information of positive fragments (generated from the function getFragment)
#' @param negFragments the data frame contains the information of negative fragments (generated from the function getFragment)
#' @param keptPosWin the data frame contains the information of positive kept windows 
#' @param keptNegWin the data frame contains the information of negative kept windows 
#' @param win the size of the sliding windows
#' @param step the size of the step of sliding windows
#' @param errorRate the probability that an RNA read takes the false strand
#'
#' @return A list of two vectors containing the positive and negative alignments to be kept.
#' 
#' @seealso getFragment, filterOne, filterMulti
#' 
#' @examples
#' posFragments <- data.frame("group"=sample(1:800,1000,replace=TRUE),"start"=sample(1:1000000,1000,replace=TRUE)) 
#' posFragments <- posFragments[order(posFragments$start),] %>% dplyr::mutate(end=start+sample(50:100,1000,replace=TRUE))
#' negFragments <- data.frame("group"=sample(1:800,1000,replace=TRUE),"start"=sample(1:1000000,1000,replace=TRUE)) 
#' negFragments <- negFragments[order(negFragments$start),] %>% dplyr::mutate(end=start+sample(50:100,1000,replace=TRUE))
#' keptPosWin <- data.frame("win"=sample(1:10000,5000,replace=FALSE),"propor"=runif(5000, min=0.7, max=1))
#' keptPosWin <- keptPosWin[order(keptPosWin$win),]
#' keptNegWin <- data.frame("win"=sample(1:10000,5000,replace=FALSE),"propor"=runif(5000, min=0, max=0.3))
#' keptNegWin <- keptNegWin[order(keptNegWin$win),]
#' win <- 1000
#' step <- 100
#' errorRate <- 0.01
#' reads <- rnaCleanR::keepRead(posFragments,negFragments,keptPosWin,keptNegWin,win,step,errorRate)
#' 
#' @export
#' 
keepRead <- function(posFragments, negFragments, keptPosWin, keptNegWin, win, step, errorRate) {
    .Call('rnaCleanR_keepRead', PACKAGE = 'rnaCleanR', posFragments, negFragments, keptPosWin, keptNegWin, win, step, errorRate)
}

