# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title  Compute strand information of sliding window 
#'
#' @description Compute the positive proportion and the value to be tested afterward to decide wheather the window is kept or not (this value is calculated from the estimated proportion and error)
#'
#' @param covPosLen the run length of an Rle object which is the coverage comes from positive reads
#' @param covPosVal the run value of an Rle object which is the coverage comes from positive reads
#' @param covNegLen the run length of an Rle object which is the coverage comes from negative reads
#' @param covNegVal the run value of an Rle object which is the coverage comes from negative reads
#' @param end the last base on the reference chromosome that the sliding window atteint
#' @param readLength the average length of reads
#' @param win the size of the sliding window
#' @param step the step of the sliding window
#' @param minCov if a window has the max coverage least than minCov, then it will be rejected
#' @param maxCov if a window has the max coverage greater than maxCov, then it will be kept
#' @param logitThreshold the logit of the threshold
#'
#' @return A list of two data frames Plus and Minus which respectively contains information of positive windows and negative windows: 'win' is the window number, and 'value' is the normalized estimated value to be tested
#' Each data frame contains contain the information of window number, proportion of postive reads, and the value to be tested afterward to decide wheather the window is kept or not (this value is calculated from the estimated proportion and error)
#' @examples
#' bamfilein <- system.file("data","s1.chr1.bam",package = "rnaCleanR")
#' alignment <- GenomicAlignments::readGAlignments(bamfilein) 
#' alignmentInChr1 <- alignment[seqnames(alignment)=="1"] 
#' covPos <- alignmentInChr1[strand(alignment)=="+"] %>% GenomicAlignments::coverage() 
#' covNeg <- alignmentInChr1[strand(alignment)=="-"] %>% GenomicAlignments::coverage() 
#' len <- length(covChr)
#' readLength <- 100
#' win <- 1000
#' step <- 100
#' minCov <- 0
#' maxCov <- 0
#' logitThreshold <- binomial()$linkfun(0.7) 
#' windows <- computeWin(runLength(covPos),runValue(covPos),runLength(covNeg),runValue(covNeg),readLength,len,win,step,minCov,maxCov,logitThreshold)
#' 
#' @export
#' 
computeWin <- function(covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov, maxCov, logitThreshold) {
    .Call('rnaCleanR_computeWin', PACKAGE = 'rnaCleanR', covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov, maxCov, logitThreshold)
}

#' @title  Compute strand information of sliding window (plot version)
#'
#' @description Compute the positive proportion, sum of reads, max coverage and the group of each window. Windows are grouped based on their maximum coverage. By default definition, groups spead from 1 to 8, which correspond to the max coverage respectively in the range "0-10","10-20","20-50","50-100","100-200","200-500","500-1000",">1000"
#' This method is used when we only need the information to plot, and do not need to filter the reads afterward.
#' 
#' @param covPosLen the run length of an Rle object which is the coverage comes from positive reads
#' @param covPosVal the run value of an Rle object which is the coverage comes from positive reads
#' @param covNegLen the run length of an Rle object which is the coverage comes from negative reads
#' @param covNegVal the run value of an Rle object which is the coverage comes from negative reads
#' @param end the last base on the reference chromosome that the sliding window atteint
#' @param readLength the average length of reads
#' @param win the size of the sliding window
#' @param step the step of the sliding window
#' @param minCov if a window has the max coverage least than minCov, then it will be rejected
#' @param maxCov if a window has the max coverage greater than maxCov, then it will be kept
#' @param logitThreshold the logit of the threshold
#'
#' @return A list of two data frames Plus and Minus which respectively contains information of positive windows and negative windows: 'win' is the window number, and 'value' is the normalized estimated value to be tested
#' Each data frame contains contain the information of proportion of postive reads, the max coverage and the group of max coverage
#' @examples
#' bamfilein <- system.file("data","s1.chr1.bam",package = "rnaCleanR")
#' alignment <- GenomicAlignments::readGAlignments(bamfilein) 
#' alignmentInChr1 <- alignment[seqnames(alignment)=="1"] 
#' covPos <- alignmentInChr1[strand(alignment)=="+"] %>% GenomicAlignments::coverage() 
#' covNeg <- alignmentInChr1[strand(alignment)=="-"] %>% GenomicAlignments::coverage() 
#' len <- length(covChr)
#' readLength <- 100
#' win <- 1000
#' step <- 100
#' minCov <- 0
#' maxCov <- 0
#' logitThreshold <- binomial()$linkfun(0.7) 
#' windows <- computeWinPlot(runLength(covPos),runValue(covPos),runLength(covNeg),runValue(covNeg),readLength,len,win,step,minCov,logitThreshold)
#' 
#' 
#' @export
#' 
computeWinPlot <- function(covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov) {
    .Call('rnaCleanR_computeWinPlot', PACKAGE = 'rnaCleanR', covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov)
}

#' @title  Compute strand information of sliding window (verbose version)
#'
#' @description non
#'
#' @param covPosLen the run length of an Rle object which is the coverage comes from positive reads
#' @param covPosVal the run value of an Rle object which is the coverage comes from positive reads
#' @param covNegLen the run length of an Rle object which is the coverage comes from negative reads
#' @param covNegVal the run value of an Rle object which is the coverage comes from negative reads
#' @param end the last base on the reference chromosome that the sliding window atteint
#' @param readLength the average length of reads
#' @param win the size of the sliding window
#' @param step the step of the sliding window
#' @param minCov if a window has the max coverage least than minCov, then it will be rejected
#' @param maxCov if a window has the max coverage greater than maxCov, then it will be kept
#' @param logitThreshold the logit of the threshold
#'
#' @return A list of two data frames Plus and Minus which respectively contains information of positive windows and negative windows: 'win' is the window number, and 'value' is the normalized estimated value to be tested
#' Each data frame contains contain the information of window number, proportion of postive reads, the value to be tested afterward to decide wheather the window is kept or not (this value is calculated from the estimated proportion and error), the sum of coverage, the max coverage and the group of max coverage
#' @examples
#' bamfilein <- system.file("data","s1.chr1.bam",package = "rnaCleanR")
#' alignment <- GenomicAlignments::readGAlignments(bamfilein) 
#' alignmentInChr1 <- alignment[seqnames(alignment)=="1"] 
#' covPos <- alignmentInChr1[strand(alignment)=="+"] %>% GenomicAlignments::coverage() 
#' covNeg <- alignmentInChr1[strand(alignment)=="-"] %>% GenomicAlignments::coverage() 
#' len <- length(covChr)
#' readLength <- 100
#' win <- 1000
#' step <- 100
#' minCov <- 0
#' maxCov <- 0
#' logitThreshold <- binomial()$linkfun(0.7) 
#' windows <- computeWinVerbose(runLength(covPos),runValue(covPos),runLength(covNeg),runValue(covNeg),readLength,len,win,step,minCov,maxCov,logitThreshold)
#' 
#' @export
#' 
computeWinVerbose <- function(covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov, maxCov, logitThreshold) {
    .Call('rnaCleanR_computeWinVerbose', PACKAGE = 'rnaCleanR', covPosLen, covPosVal, covNegLen, covNegVal, readLength, end, win, step, minCov, maxCov, logitThreshold)
}

#' @title  Get the indices of positive and negative reads in a given alignment
#'
#' @description non
#'
#' @param strand a string vector contain the "+" or "_"
#'
#' @return A list of two vectors which contains the order of each positive, negative strands within the input strand vector
#' 
#' @examples
#' strand <- rep("+",1000)
#' negInd <- sample(1:1000,400,replace = FALSE)
#' strand[negInd] <- "_"
#' index <- getIndex(strand)
#' 
#' 
#' @export
#' 
getIndex <- function(strand) {
    .Call('rnaCleanR_getIndex', PACKAGE = 'rnaCleanR', strand)
}

keepRead <- function(posFragments, negFragments, keptPosWin, keptNegWin, win, step, errorRate) {
    .Call('rnaCleanR_keepRead', PACKAGE = 'rnaCleanR', posFragments, negFragments, keptPosWin, keptNegWin, win, step, errorRate)
}

